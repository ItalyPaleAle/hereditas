{#await contentPromise}
    Loading...
{:then content}
    <nav aria-label="breadcrumb">
        <ol class="breadcrumb">
            <li class="breadcrumb-item"><a href="/list/" use:link>home</a></li>
            {#each content.path as path, i}
                <li class="breadcrumb-item"><a href="/list/{content.path.slice(0, i + 1).join('/') + '/'}" use:link>{path}</a></li>
            {/each}
            <li class="breadcrumb-item active" aria-current="page">{content.name}</li>
        </ol>
    </nav>

    {#if content.display == 'text'}
        <pre>{content.text}</pre>
    {:elseif content.display == 'html'}
        {@html content.text}
    {:elseif content.display == 'image'}
        <img src="{content.blob}" alt="{content.name}" class="img-fluid" />
    {:else}
        Download: <a href="{content.blob}" download="{content.name}">{content.name}</a>
    {/if}
{:catch error}
    Error: {error}
{/await}


<script type="text/javascript">
import {getHistory} from '../../vendor/svelte-routing'
import link from '../../vendor/svelte-routing/link'

export default {
    computed: {
        contentPromise: ({match, $box}) => {
            // Get the name of the element
            // The element variable should be an id, a hex string of 24 chars
            const elementId = (match && match.params && match.params.element) || ''
            if (!elementId || !elementId.match(/^[0-9a-f]{24}$/)) {
                return Promise.reject('Invalid content')
            }

            // Get info on the content
            const contents = $box.getContents()

            // Get the tag from the index
            let element
            for (const i in contents) {
                if (contents[i].dist == elementId) {
                    element = contents[i]
                    break
                }
            }
            if (!element) {
                return Promise.reject('Content not found')
            }

            // Fetch the data
            return $box.fetchContent(element)
                .then((result) => {
                    // Build the URL for attachments and images, and get the file name
                    if (result.display != 'text' && result.display != 'html') {
                        // Convert data to a Blob
                        result.blob = URL.createObjectURL(new Blob([result.data], {type: "octet/stream"}))
                        delete result.data
                    }

                    // Get the path components
                    result.path = element.path.split('/')
                    result.name = result.path.pop()

                    return result
                })
                .catch((error) => {
                    // Log the error
                    console.error(error)

                    return error
                })
        }
    },

    oncreate() {
        // Ensure that we have unlocked the box
        const {box} = this.store.get()
        if (!box.isUnlocked()) {
            // Do this in the next tick
            setTimeout(() => {
                getHistory().replace('/')
            }, 0)
        }
    },

    actions: {
        link
    }
}
</script>
